- Группа: УИБО-14-24
- Студент: Мартыненко Даниил
- Вариант: 8 
- Вопрос: 3

---

# Рекурсивное вычисление суммы элементов массива

## Python

**Как работает алгоритм:**
- **Базовый случай**: `if index == len(arr): return 0` - достигнут конец массива
- **Рекурсивный случай**: `return arr[index] + array_sum(arr, index + 1)` - текущий элемент + сумма остальных

**Процесс выполнения:**

```
Объяснение вывода 15:

array_sum([1,2,3,4,5], 0)
→ 1 + array_sum([1,2,3,4,5], 1)
→ 1 + (2 + array_sum([1,2,3,4,5], 2))
→ 1 + (2 + (3 + array_sum([1,2,3,4,5], 3)))
→ 1 + (2 + (3 + (4 + array_sum([1,2,3,4,5], 4))))
→ 1 + (2 + (3 + (4 + (5 + array_sum([1,2,3,4,5], 5)))))
→ 1 + (2 + (3 + (4 + (5 + 0))))
→ 1 + (2 + (3 + (4 + 5)))
→ 1 + (2 + (3 + 9))
→ 1 + (2 + 12)
→ 1 + 14
→ 15
```

**Временная сложность:** O(n)

**Объяснение временной сложности:**
- Выполняется **ровно n рекурсивных вызовов** (по одному на каждый элемент массива)
- На каждом уровне выполняется **O(1) операций**: сравнение индекса, доступ к элементу массива, сложение
- **Общее время**: n × O(1) = O(n)
- **Глубина рекурсии**: O(n) - каждый вызов добавляет фрейм в стек Python
- **Максимальная глубина**: ограничена `sys.getrecursionlimit()` (~1000 вызовов)

---

## C++

**Как работает алгоритм:**
- **Базовый случай**: `if (index == arr.size()) return 0;` - конец массива
- **Рекурсивный случай**: `return arr[index] + array_sum(arr, index + 1);` - элемент + сумма хвоста

**Временная сложность:** O(n)

**Объяснение временной сложности:**
- **n рекурсивных вызовов** - каждый элемент массива обрабатывается одним вызовом
- **Операции на уровень**: сравнение индексов, доступ к элементу вектора, сложение, инкремент индекса
- **Пространственная сложность**: O(n) из-за стека вызовов
- **Ограничение**: зависит от размера стека компилятора (обычно 1-8 МБ)

---

## Java

**Как работает алгоритм:**
- **Базовый случай**: `if (index == arr.length) return 0;` - завершение рекурсии
- **Рекурсивный случай**: `return arr[index] + arraySum(arr, index + 1);` - накопление суммы

**Временная сложность:** O(n)

**Объяснение временной сложности:**
- **Количество вызовов**: ровно n раз (по количеству элементов в массиве)
- **Время на вызов**: O(1) - примитивные операции (сравнение, доступ к элементу, сложение)
- **Стек вызовов**: O(n) фреймов в стеке JVM
- **Риск**: StackOverflowError при больших массивах из-за глубины рекурсии

---

## ❓ Почему наивная рекурсивная реализация чисел Фибоначчи неэффективна?

**Ответ:** Наивная рекурсивная реализация Фибоначчи имеет **экспоненциальную сложность O(2ⁿ)** из-за:

1. **Двойной рекурсии**: каждый вызов `fib(n)` порождает **два новых вызова** - `fib(n-1)` и `fib(n-2)`

2. **Повторных вычислений**: одни и те же значения вычисляются многократно
   - Например, `fib(5)` вычисляет `fib(3)` два раза, `fib(2)` три раза

3. **Экспоненциального роста дерева вызовов**:
```text
fib(5)
├── fib(4)
│   ├── fib(3)
│   │   ├── fib(2)
│   │   └── fib(1)
│   └── fib(2)
└── fib(3)
    ├── fib(2)
    └── fib(1)
```

4. **Огромной избыточности вычислений**: количество операций растет как 2ⁿ

**Решение**: использование мемоизации (кэширования результатов) или итеративного подхода снижает сложность до **O(n)**.
